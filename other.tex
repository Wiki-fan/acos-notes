\documentclass[main]{subfiles}

\begin{document}

\section{Системные вызовы}
Системный вызов --- это способ перехода из непривилегированного режима в
привилегированный, при этом управление передаётся ОС. Цель --- заставить ОС
сделать что-то нужное. Обычно, это реализованно с помощью вызова некоторого
прерывания, в архитектуре x86 --- 0x80. В AMD64 появилась операция syscall, предназначенная
для этого же (поговаривают, что это быстрее, но лектор ставит это под сомнение).
Возвращаемое значение обыкновенно записывается в регистр eax (часто --- $0$ или $-1$).
Системные вызовы кодируются номерами, которые, опять же, передаются через eax
перед прерыванием.

Системные вызовы мира UNIX определяются в POSIX, но в качестве C-интерфейсов, а
конкретная реализация уже оставляется на усмотрение разработчикам ОС.
По сути, выглядит это так: вы вызываете функцию read, которая выполняется
в пользовательском режиме (проверка параметров и т. п.), а потом совершает
системный вызов, когда управление уже переходит ядру. После выполнения,
восстанавливается контекст и управление снова переходит к пользовательской
функции read. Некоторые функции даже могут выполнять не один системный вызов,
например, open вначале проверит право на чтение или существование файла.

\section{Таймеры и часы}
Часы --- это внешнее устройство для процессора. Они не могут быть использованы
для ОС и программами, т. к. их разрешающая способность невелика.

Таймер, управляемый генератором тактовой частоты --- это некоторый регистр
процессора. Не особо понятно, сколько времени пройдёт между изменениями
значений этого таймера, т. к. он зависит от тактовой частоты, а она может
быть переменной, поэтому для некоторых задач он всё ещё недостаточно
точен.

Таймер реального времени не зависит от тактовой частоты, имеет высокую
разрешающую способность, но потребляет относительно много системных ресурсов.

Можно зарегистрировать прерывание на таймер, для переменной длины интервалов
создаётся таблица прерываний, в который указано, через какое количество
обращений таймера нужно вызвать указанный код, её поддерживает ОС.

В ОС есть таймеры с различной разрешающей способностью. Понятно, что если
позволить программам выполнять действия раз в наносекунду, можно заставить
ОС выделить всё время только на обработку событий. Поэтому на таймеры от
программ накладываются серьёзные ограничения, например --- не более одного
события в $10$ наносекунд.

\section{Watchdog}
Собака спит, пока кто-нибудь не позвонит в дверь, тогда она начинает лаять.

Watchdog позволяет отследить, что программа достигла некоторого состояния и
среагировать на это. Как это реализовано? Выделяется некоторый регистр,
высокоприоритетное прерывание и некоторый таймер. В регистр пишется
некоторое значение. Каждое срабатывание таймера регистр уменьшается. Но если компьютер 
работает нормально, то он успевает выставить изначальное значение на регистре,
и обнуления не происходит. Если же компьютер повис, то этого не происходит, 
регистр обнуляется и вызывается прерывание.Если процессор
может обработать его, то появляется BSOD с информацией о памяти, или, например,
система автоматически перезагружается (возможны различные действия).
Такие устройства присутствуют не во всех устройствах, редки на личных ПК.
\end{document}
