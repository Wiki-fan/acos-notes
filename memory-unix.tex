\documentclass[main]{subfiles}

\begin{document}
\chapter{Память в POSIX}
Вся память организована из регистров, кэша, оперативной памяти и свопа.
Команда free позволяет узнать информацию о том, как используется
память.

Для вытеснение памяти в swap заводится отдельная таблица, которая
содержит число обращений к страницам. По таймеру ОС проверяет
таблицу страниц на наличие обращений, грязности и модифицирует
эту таблицу.
В зависимости от содержимого этой таблицы выбирается
страница, которая будет отправлена в своп при необходимости:
выбрасывается та, у которой значение счётчика наименьшее.
Для этого используются различные алгоритмы, например --- LRU и NRU.
Бывают различные тонкости: например, недавно записанная но не прочитанная
страница может быть важнее той, из которой недавно читали.

\section{Выделение памяти}
Выделение памяти делится на два вида: выделение в ядре (в свою очередь, с помощью
buddy для быстрого выделения небольших участков --- get\_free\_pages и slab для больших --- kmalloc) и
в пользовательском режиме. В пользовательском режиме --- это malloc
(реализуется с помощью ptmalloc2 --- наследника dlmalloc), тут оно уже происходит
не только кратно размеру страницы. Зачем нужно выделение памяти
Есть проблема фрагментации: если куски рабочей памяти разбросаны по оперативной, это
повышает вероятность промаха кэша.

Когда мы выделяем память (с помощью get\_free\_pages), происходит поиск зоны,
которая больше всего подходит для этого размера. Мы берём наименьший подходящий
промежуток.
Такой метод используется для
достаточно быстрых операций, например --- для хранения семафоров.

По kmalloc выделяется зона по определённому адресу, указывается её размер.
Когда приходит следующий запрос, при возможности выбирается та же зона.
Если какой-то диапазон использован неполностью, то его можно дополнить
новыми объектами. Если же диапазоны исчерпаны, то запрашивается новый.

Если наше приложение многопоточно, то это неэффективно. У всех потоков
одного процесса куча и сегмент данных один. Если же мы захотели в одном
потоке выделить память, то на время выполнения malloc придётся блокировать
этот механизм для всех остальных потоков. Для обхода этой проблемы придумано
множество ухищрений. Например, tcmalloc (разработан Google) или
jemalloc (по умолчанию в FreeBSD, также используется Mozilla).

\section{ptmalloc2}
Идея такова: у нас есть сегмент данных, в нём заводится "арена" --- то место, где
можно выделять память. У неё есть заголовок и список пустых пространств.
Алгоритм, в целом, выглядит как и slab. Изначально арены отсутствуют
или имеют минимальный размер. По возможности, мы работаем с текущей ареной,
если памяти не хватает --- мы расширяем сегмент данных вызовом brk.

В реальности есть такая настройка, как vm orevcommit, которая может быть
установлена в 0, 1 или 2. При  --- остутствие ограничений памяти, по необходимости
будет убит процесс с высоким pid, который выделял недавно память и выделит её много,
для освобождения памяти. 1 --- при недостатке памяти произойдёт kernel panic.
2 --- запретить overcommit, т. е. не выделять память при заполненном свопе.

overcommit\_ratio --- на сколько можно.

Зачем нужны арены? После вызова malloc возрвращается адрес, и соответсвтующий
ему диапазон помечается занятым.

Арена создаётся на каждое ядро процессора при создании потока.

Для malloc и free в потоках используется mmap, у каждого --- своя арена.
Когда происходит освобождение памяти, сегмент данных не уменьшается, максимум ---
отключается отображение виртуальной памяти в физическую.

\section{tcmalloc}
На низком уровне он пользуется стандартный malloc, но запоминает её,
и память принадлежит конкретным потокам. Таким образом, достигается минимицазия
обращений к глобальной куче.

\section{jemalloc}
Вся память, которая доступна, делится на равные фрагменты для каждого ядра
процессора и в каждой из них заводится отдельная куча. Таким образом,
исключаются перекрытия и проблемы (пока не потребуется выделить памяти больше,
чем память делённая на число ядер).
\end{document}
