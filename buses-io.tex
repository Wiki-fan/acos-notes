\documentclass[main.tex]{subfiles}

\begin{document}

\section{Шина и прерывания}
Требуется какое-то число тактов на подготовку данных, после чего их можно считать.
Всё в принципе, замечательно. В чём проблема?
Понятно, что каждая линия --- проводник на нашей схеме, чем их больше ---
тем сложнее электрическая обвязка, тем это дороже, выше шанс ошибки.
Поэтому в первой шине ISA
было ограничено количество проводников. Даже в шине PCI используется 32 проводника.
Мы можем увеличивать частоту шины, но тут мы также лимитированы: нужно, чтобы
отработала логика и сигнал успел распространиться по всей шине
(один из проводников может быть длиннее других --- перекос шины).
Поэтому, мы лимитированы по возможности ускорения обмена.

Начиная с конца девяностых для шины памяти стали использовать не параллельную
шину, когда передаётся одно слово, а система, когда данные передаются за несколько
тактов шины, что стало сложнее.

С одной стороны, параллельная шина проще, её легче сделать, но чем быстрее
становились шины, тем чаще стали переходить на последовательные шины.
У нас есть линии, отвечающие за передачу данных, возможно, адреса, и управляющие
линии --- команды для устройства, линии прерываний, линии управления питанием.

В какой-то момент процессоры и память сильно ускорились, но устройства ввода-вывода
отставали, т. к. использовали другие протоколы, поэтому шина между процессором
и памятью была отделена от шин ввода-вывода: шины ввода-вывода были вынесены за
отдельное устройство --- мост. Мост работал на одной частоте с ЦП и памятью,
поддерживал кэширование и т. д.

Есть линии, отвечающие за задание адреса и, отдельно, за задание данных.
В итоге, в середине 90х, когда появилась шина PCI, уже требовалось
32 бита на адреса, 32 на данные, и ещё на команды --- требуется очень много
проводников. Именно поэтому была реализована следующая модель:
по одной 32-х разрядной шине передаются последовательно команда, адрес
и данные, что позволило существенно уменьшить число проводников.
Однако, в таком варианте проблемной становится передача блоков по
несколько слов: для каждого слова передаётся команда и адрес,
что избыточно. Поэтому в PCI поддерживается burst --- передаётся
команда, адрес и число слов данных.

В чём недостатки? Пусть у нас есть некоторая последовательность некоторых данных,
которые нужно отправить по сети. Но процессору требуется все данные пропускать
через себя и регулярно контролировать обмен между памятью и устройством, а
хочется сказать памяти или устройству, что нужно передать много-много данных
и продолжать вычисления. Эту старую проблему решили ещё во времена мейнфреймов:
пусть у нас будет отдельное устройство --- DMA, которому процессор скажет:
необходимо выдать из памяти с такого адреса столько-то данных устройству по
такому адресу. В старых шинах такой контроллер был один на шину, но практически
на всех современных устройствах такой контроллер встроен практически в каждое
устройство.

Но тогда появляются непонятки: есть процессор, который может
передавать данные устройству, и контроллер, который тоже может это делать.
Как же их согласовать? Для этого используется арбитраж шины.
Для этого есть разные механизмы: когда устройства пытаются выяснить,
кто из них будет передавать данные сейчас по специальной линии арбитража,
занятости (показывает, можно ли эту шину использовать) и свободности.
Если устройству необходимо передавать данные, оно проверяет свободность
шины, занимает её и передаёт данные, если не нужно --- отправляет
сигнал свободности далее. Основная проблема в том, что появляется
приоритизация: то, как часто сможет работать устройство зависит от того,
насколько оно близко к началу, есть пути решения этой проблемы, но это
довольно сложно. При разработке PCI решили делать проще:
есть некоторый арбитр, к которому присоединены все устройства,
и именно он решает, когда будут работать устройства, что позволяет
работать "честно" или, при необходимости вводить приоритеты.

Но жизнь не стоит на месте, и уже всё намного сложнее. У нас может
быть шина, мост на какую-то другую шину, к которой могут быть
подключены устройства и контроллер PCI, к которой подключены
устройства и контроллер шины ISA --- довольно сложная иерархия.
Как уже было сказано, каждый обмен задаётся адресом; с память всё понятно ---
это указывает, с какой ячейкой памяти нужно работать. Но помимо памяти есть и
другие устройства, как же их адресовать? На самом деле, для этого используется
та же схема, за каждым устройством регистрируется небольшое адресное
пространство, например, 512 слов, и начиная с некоторого базового адреса
память отводится этому устройству, эти адреса игнорируются памятью
и направляются устройству. Одна из довольно очевидных проблем ---
как понять, какие адреса нужно использовать для работы с устройствами?
Можно жёстко задать адреса для шины: пусть для шины есть не больше 10 устройств
и реализовать несколько джамперов, которые сообщают устройству его
адреса --- так работала шина ISA. Это довольно печально, ведь требуется
работа на стороне железа, нужно сообщать программам адреса устройств,
поэтому стали искать способы автоматически всё это конфигурировать.
На архитектуре x86 такой способ появился с PCI.
К имеющимся линиям были добавлены отдельные, которые использовались для
инициализации: когда на этой линии был высокий уровень, принимаемые данные
воспринимались как базовый адрес. На самом деле, в случае PCI всё немного
сложнее, эта линия давала устройству понять, что работают именно с ним и
нужно открыть доступ к специальной конфигурационной памяти, что позволяло
по очереди настроить каждое устройство при запуске компьютера и не мучаться
с физической стороной вопроса.

Итак, мы уже можем обмениваться данными с устройством или заставлять его
делать это самостоятельно. Но нужно узнать, что устройство закончило работу
DMA, или узнать, что устройство получило данные (например, сетевая карта
получила данные). Для этого используются прерывания --- паттерн работы
ЦП, при котором процессор приостанавливает выполнение программы и запускает
программу-обработчик прерывания, когда на определённой ножке установлен
высокий уровень (понятно, что дальнейшая обработка прерываний приостанавливается).
Этот обработчик связывается с устройством, выполняет необходимые действия
и уведомляет устройство о том, что прерывание обработано.
Тут используется стек, в который помещается адрес возврата и содержимое регистра
для восстановления работы после обработки прерывания. Тут проблема в том, что
работа с памятью достаточно медленна. На самом деле, есть механизм, который
реализует неглубокий стек регистров на процессоре и при прерывании данные
сохраняются туда, но такая модель используется не на распространённых архитектурах,
например, на Intel Itanium.

Тут появляется новая проблема: от каждого устройства нужно проводить линию
прерывания, а это может потребовать очень много ножек. Можно использовать одну
ножку, но как тогда определять устройство, сгенерировавшее прерывание?
Поэтому придумали такую штуку, как PIC, у которой есть много входов для
прерываний и один выход на процессор. Это устройство получив прерывание
запоминает устройство, вызывает прерывание процессору и отправляет ему
номер прерывания --- идентификатор устройства.
Опять же, количество входов PIC ограничено. Чтобы решить и эту проблему
к нему можно подключить другой PIC и передавать код уже с него и т. д.
Однако, на практике всё сложней. Устройств довольно много и закладывать
PIC на все --- дорого.

В PCI используется всего четыре линии прерываний (A, B, C, D), т.  к.
обычно подключено довольно мало устройств. К сожалению, большая часть
производителей стали использовать линию A :)
Кроме того, потребовалась эффективная работа с многопроцессорными системами.
Тогда Intel разработали новую технологию --- APIC. У таких устройств есть
несколько входов и выходов, и через специальный интерфейс процессор
может развести разные типы прерываний по разным выходам. Это принесло много
усложнений, но дало гибкость.
К сожалению, это всё ещё не решило проблему с несколькими устройствами
на одной линии.

Таким образом шина PCI дожила до начала 2000-х годов, когда её производительности
стало категорически не хватать, и даже возможность работы в 64-битном режиме
не давала требуемого развития. Даже для обновления в реальном времени экрана
монитора с высоким разрешением было невозможно. Было решено  разработать новую,
более быструю шину, но схожую с PCI, её назвали PCI-Express.
Она уже была последовательной (команда -> адрес -> данные), что позволило
увеличить частоту и уменьшить число проводников к шине, а потому избавиться
от проблем арбитража, подключая устройства лишь частью проводников (и
регулировать их количество для устройств).
Чтобы не согласовывать передачу данных с процессором, она также была сделана
двунаправленной. Чтобы избежать сложности APIC использовалась технология
MSI --- прерывания отправлялись по шине данных. По исследованиям Intel,
переход на APIC ускорил обработку прерываний в три раза, а на MSI ---
до семи раз.

Как же происходит непосредственное взаимодействие с устройством?
Для совсем примитивных случаев всё просто, есть вход и выход, процессор может
читать и писать данные, устройство может отправлять прерывания.
Однако, теперь процессор активно управляет устройством, должен за короткий
промежуток времени считать данные с устройства и т. д.
Современные устройства представляют собой микрокомпьютер: есть свой
контроллер шины, внутренний процессор и память, данные передаются
не на ЦП/оперативную память, но буферизуются на самом устройстве.
Взаимодействие с таким устройством осуществляется, опять же, через
выделенное адресное пространство. Типичная картина взаимодействия такова:
устройство экспортирует регистр статуса, какой-то управляющий регистра,
регистр адреса, регистр данных и регистр прерываний (это называется регистровой моделью устройства).
Тогда ЦП использует программу-драйвер для отправки данных устройству,
этот драйвер вначале передаёт данные во внутреннюю память
(указать адрес, отправить данные в регистр данных и т. д. для каждого слова),
после чего в управляющий регистр выставляется бит вроде "начни выдачу данных".
Отобразить всю внутреннюю память можно лишь при её небольших объёмах
и требует синхронизации шины компьютера и внутренней шины устройства.
Для получения данных процессор отправляет нужную команду, устанавливает
статус и регистр прерывания, и отправляет прерывание процессору
(может быть несколько устройств на одном прерывании, тогда последовательно
опрашиваются все подходящие устройства на наличие прерывания).

Как уже было сказано, все регистры отображаются в глобальное адресное пространство.
Современные компиляторы при оптимизации могут исключить бессмысленные для
обычной памяти операции, которые подразумевают изменения регистров, поэтому
нужно уведомлять компилятор об особом статусе некоторых адресов.
На некоторых архитектурах также нужно уведомлять систему кэширования о таких
адресах.

Также стоит заметить, что можно не полностью отключать все прерывания в момент
обработки одного из них для работы с несколькими процессорами.
\end{document}
