\documentclass[main]{subfiles}

\begin{document}

\subsection{Архитектуры}
Почти все современные компьютеры работают по принципам, сформулированными
фон Нейманом. Машина фон Неймана имеет следующие компоненты:
\begin{itemize}
\item Процессор
\item Оперативная память
\item Устройство ввода
\item Устройство вывода
\end{itemize}
Также должны быть выполнены следующие принципы:
\begin{enumerate}
\item Принцип двоичного кодирования: и данные, и команды представлены в
двоичном виде
\item Принцип программного управления: процессор поддерживает некоторое
множество команд и управляется машина программой --- некоторой
последовательностью таких команд; разрешена команда перехода, которая
позволяет изменять последовательность команд
\item Принцип адресности: оперативная память разделена на
ячейки равного размера, каждая из которых имеет номер --- её адрес;
можно обращаться к произвольной ячейке по её адресу
\item Принцип однородности (хранимой программы):
программа хранится в памяти и неотличима от данных
\end{enumerate}

Такая архитектура имеет следующие проблемы:
\begin{itemize}
\item Можно неверно интерпретировать данные как программу и наоборот
\item Нет защиты одних программ от других
\end{itemize}

Независимо была также разработана Гарвардская архитектура, которая
отличается наличием двух видов оперативной памяти:
в одной хранятся данные, а в другой --- инструкции.
Однако, в таком варианте нельзя изменить программу.

\begin{remark}
Любая современная архитектура не соответствует одним из них полностью;
существует множество абстракций, которые призваны решить проблемы
этих архитектур.
\end{remark}

\subsection{Устройство процессора}
Можно разделить компоненты процессора на следующие классы:
\begin{itemize}
\item Управляющие устройства
\item Арифметико-логическое устройства
\item Регистры (часть из них недоступная программисту ---
теневые регистры)
\item Кэш (для простоты будем считать, что работа ведётся напрямую с памятью)
\end{itemize}

Команду обыкновенно разделяют на следующие части:
код команды, размер операндов (иногда относится к коду) и сами операнды.
Часто команды разделяют по количеству операндов (наиболее распространены
двухадресные команды).

Системы команд часто разделяют на две категории:
CISC (Complete Instructions Set) и RISC (Reduced Instructions Set).
Первые предполагают наличие инструкций для большого числа слуачев
с разной длинной кодов
(должно быть удобно для программистов, но влечёт сложность декодирования
команд), вторые --- наоборот, содержат минимальное число команд с
фиксированным размером (позволяет читать несколько инструкций,
проще в реализации).

Также существует архитектура VLIW (Very Large Instruction Word),
особенностью которой является возможность выполнения одновременных
операций со всеми арифметико-логическими устройствами,
что позволяет тонко оптимизировать программы; однако, это
существенно увеличивает размер программ и сложность компиляторов.
Одной из реализаций была архитектура Itanium.
Теперь эта концепция получила продолжение в виде технологии
Hyperthreading.

Нет инструкций память-память.
IP --- 16бит, EIP --- 32бит, RIP --- 64бит.
Этот регистр нельзя изменять напрямую: для этого нужно использовать
команды условного или безусловного перехода:
jmp (безусловный переход), je, jg, jnz и т. д.

Для копирования данных используются команды mov[l|r] с суффиксом, обозначающим
размер копируемых данных (без --- 16 бит, l --- 32, r --- 64), принимается
два аргумента --- откуда и куда копировать (два регистра, либо регистр и адрес в памяти);

Арифметические операции: add (добавить к одному аргументу-регистру значение второго
аргумента), mul, sub, div. Из-за ограниченного размера регистров существует флаг
переполнения, который содержится в регистре-флаге. Возможность деления на ноль
приводит к необходимости прерываний (для обработки событий другим кодом),
а они приводят к необходимости стека для сохранения состояния регистров.

Битовые операции: shift[r|l] и т. д.

Работа со стеком: push, pop. Указатель на вершину стека находится в
регистре SP; в отличии от IP, доступен к изменению.

Инструкции для работы с процедурами: call, ret.

nop --- инструкция, которая не делает ничего.

Ввод-вывод: in, out, mov. Тут снова требуются прерывания --- для
обработки новых данных.

Spinlock --- схема, используемая для доступа несколькими процессами
к одному разделяемому ресурсу: используется флаг, который показывает,
занят ли ресурс некоторым процессом.

Порядок размещения многобайтовых чисел различен:
Little Endian --- младшие разряды по младшим адресам,
и Big Endian --- наоборот.

Сами команды представляются в двоичном коде, но для удобства
их записывают мнемониками, а их переводит в двоичный код
программа-ассемблер. В этом курсе предполагается использование
ассемблера GAS (GNU Assembler) с AT\&T синтаксисом.

\end{document}
